const axios = require("axios");

class OllamaService {
  constructor() {
    this.baseURL = process.env.OLLAMA_HOST || "http://localhost:11434";
    this.model = process.env.OLLAMA_MODEL || "gemma:2b";
    this.timeout = parseInt(process.env.OLLAMA_TIMEOUT) || 120000;
  }

  async initializeAI() {
    try {
      const response = await axios.get(`${this.baseURL}/api/tags`);
      const models = response.data.models || [];

      if (
        !models.find(
          (m) => m.name === this.model || m.name === `${this.model}:latest`
        )
      ) {
        console.log(`‚ö†Ô∏è Modelo ${this.model} no encontrado, usando tinyllama`);
        this.model = "tinyllama";
      }

      console.log("‚úÖ Ollama conectado correctamente");
      console.log(
        "üì¶ Modelos disponibles:",
        models.map((m) => m.name)
      );
      return true;
    } catch (error) {
      console.error("‚ùå Error conectando con Ollama:", error.message);
      throw error;
    }
  }

  async generateResponse(prompt, options = {}) {
    try {
      console.log("ü§ñ Enviando prompt a Ollama...");
      const startTime = Date.now();

      const response = await axios.post(
        `${this.baseURL}/api/generate`,
        {
          model: options.model || this.model,
          prompt: prompt,
          stream: false,
          options: {
            temperature: options.temperature || 0.7,
            top_p: 0.9,
            num_predict: options.maxTokens || 1024,
            num_ctx: 4096,
            repeat_penalty: 1.1,
          },
        },
        { timeout: this.timeout }
      );

      const endTime = Date.now();
      console.log(`‚úÖ Respuesta recibida en ${(endTime - startTime) / 1000}s`);

      return response.data.response;
    } catch (error) {
      console.error("‚ùå Error generando respuesta:", error.message);

      // Si falla con gemma, intentar con tinyllama
      if (this.model !== "tinyllama" && options.model !== "tinyllama") {
        console.log("üîÑ Intentando con tinyllama...");
        return this.generateResponse(prompt, {
          ...options,
          model: "tinyllama",
        });
      }

      throw error;
    }
  }

  async analizarEntrenamiento(datosEntrenamiento) {
    const prompt = this.construirPromptAnalisis(datosEntrenamiento);
    return this.generateResponse(prompt, {
      temperature: 0.7,
      maxTokens: 1500, // M√°s tokens para an√°lisis completo
    });
  }

  construirPromptAnalisis(datos) {
    const {
      entrenamientoData,
      duracionTotal,
      rutinaInfo,
      metricas,
      usuarioData,
      historial,
    } = datos;

    // Contexto f√≠sico del usuario (si est√° disponible)
    let contextoFisico = "";
    if (usuarioData?.peso && usuarioData?.altura) {
      const alturaMetros = usuarioData.altura / 100;
      const imc = (usuarioData.peso / (alturaMetros * alturaMetros)).toFixed(1);
      contextoFisico = `
DATOS DEL USUARIO:
- Peso actual: ${usuarioData.peso} kg
- Altura: ${usuarioData.altura} cm  
- IMC: ${imc}
${
  usuarioData.objetivoPeso
    ? `- Objetivo de peso: ${usuarioData.objetivoPeso} kg`
    : ""
}`;
    }

    // Historial de entrenamientos para ver evoluci√≥n
    let contextoHistorial = "";
    if (historial && historial.length > 0) {
      const entrenamientosAnteriores = historial
        .slice(0, 3)
        .map((workout) => {
          const fecha = new Date(workout.date).toLocaleDateString("es-ES", {
            day: "2-digit",
            month: "2-digit",
          });
          const duracionMin = Math.round(workout.duracion / 60);
          return `  ${fecha}: ${workout.totalEjercicios} ejercicios, ${workout.totalSeries} series, ${duracionMin} minutos`;
        })
        .join("\n");

      // Calcular tendencia
      let analisisTendencia = "";
      if (historial.length >= 2) {
        const duracionActual = duracionTotal;
        const duracionAnterior = historial[0].duracion;
        const diffMinutos = Math.round(
          (duracionActual - duracionAnterior) / 60
        );

        if (Math.abs(diffMinutos) < 5) {
          analisisTendencia = "Mantienes constancia en los tiempos";
        } else if (diffMinutos > 0) {
          analisisTendencia = `Has aumentado ${Math.abs(
            diffMinutos
          )} minutos respecto al √∫ltimo entrenamiento`;
        } else {
          analisisTendencia = `Has optimizado ${Math.abs(
            diffMinutos
          )} minutos respecto al √∫ltimo entrenamiento`;
        }
      }

      contextoHistorial = `
HISTORIAL RECIENTE (√∫ltimos ${historial.length} entrenamientos):
${entrenamientosAnteriores}
  Evoluci√≥n: ${analisisTendencia || "Primer entrenamiento registrado"}`;
    }

    return `Eres un entrenador personal experto. Analiza este entrenamiento de forma personalizada y profesional.
${contextoFisico}
${contextoHistorial}

ENTRENAMIENTO DE HOY:
- Rutina: ${rutinaInfo?.nombre || "Sin nombre"}
- D√≠a ${(rutinaInfo?.diaIndex || 0) + 1} de ${rutinaInfo?.totalDias || 1}
- Duraci√≥n total: ${Math.round(
      duracionTotal / 60
    )} minutos (incluyendo descansos)
- Ejercicios completados: ${entrenamientoData.length}

RENDIMIENTO DETALLADO:
${entrenamientoData
  .map((ejercicio, index) => {
    const v = ejercicio.valoracion || {};
    const seriesCompletadas =
      ejercicio.series?.filter((s) => s.completada).length || 0;
    const seriesTotales =
      (ejercicio.series?.length || 0) + (ejercicio.seriesSaltadas || 0);
    const pesoPromedio =
      ejercicio.series?.length > 0
        ? (
            ejercicio.series.reduce((sum, s) => sum + (s.peso || 0), 0) /
            ejercicio.series.length
          ).toFixed(1)
        : 0;
    const tiempoMin = Math.round((ejercicio.duracion || 0) / 60);

    return `${index + 1}. "${ejercicio.ejercicioNombre}"
   Valoraci√≥n: Satisfacci√≥n=${v.satisfaccion || 0}/5, Esfuerzo=${
      v.esfuerzo || 0
    }/5, Dificultad=${v.dificultad || 0}/5
   Ejecuci√≥n: ${seriesCompletadas}/${seriesTotales} series, ${pesoPromedio}kg promedio, ${tiempoMin} minutos
   ${
     ejercicio.seriesSaltadas > 0
       ? `‚ö†Ô∏è Series saltadas: ${ejercicio.seriesSaltadas}`
       : ""
   }
   ${v.notas ? `Notas: "${v.notas}"` : ""}`;
  })
  .join("\n")}

M√âTRICAS GLOBALES:
- Satisfacci√≥n promedio: ${metricas?.promedioSatisfaccion || 0}/5
- Esfuerzo promedio: ${metricas?.promedioEsfuerzo || 0}/5
- Dificultad promedio: ${metricas?.promedioDificultad || 0}/5
- Completado: ${metricas?.porcentajeCompletado || 0}%

INSTRUCCIONES PARA TU AN√ÅLISIS:

1. FORMATO MARKDOWN OBLIGATORIO:
   - Usa "## " para t√≠tulos principales
   - Usa "**texto**" para √©nfasis importantes
   - Usa "* " para listas de puntos

2. IDIOMA: Responde √öNICAMENTE en espa√±ol. Evita anglicismos ni palabras en ingl√©s.

3. ESTRUCTURA DEL AN√ÅLISIS:

   ## Resumen del Entrenamiento
   - Haz un an√°lisis general de 3-5 l√≠neas sobre el rendimiento global
   - Comenta la evoluci√≥n si hay historial disponible
   - Destaca los aspectos m√°s relevantes del entrenamiento
   - Usa emojis para hacerlo m√°s amigable (üí™, üéØ, üî•, etc.)

   ## An√°lisis por Ejercicio
   - Centra el an√°lisis en cada ejercicio individual
   - Si el ejercicio fue bien ejecutado: motiva y felicita (sin sugerencias t√©cnicas)
   - Si hubo problemas: 
    * Identifica el problema concreto (peso, esfuerzo, descanso, t√©cnica, dificultad)
    * Da recomendaciones espec√≠ficas y num√©ricas (ej: "reduce 5kg", "descansa 30s m√°s") 
   - Atiende siempre las notas del usuario si indican alguna molestia o dificultad

   ## Optimizaci√≥n de la Rutina
   - Analiza la **estructura global de la rutina**, no ajustes de peso ni series (eso va en ‚ÄúAn√°lisis por Ejercicio‚Äù).
   - Si hay menos de 4 ejercicios: sugiere a√±adir grupos musculares complementarios (ej: empuje, tir√≥n, core, tren inferior).
   - Si hay m√°s de 8 ejercicios: eval√∫a si reducir el volumen total para evitar sobrecarga.
   - Si los ejercicios son muy similares: sugiere variar los patrones de movimiento (ej: alternar empuje/tir√≥n, incluir trabajo unilateral).
   - No menciones el n√∫mero exacto de ejercicios a a√±adir ni ajustes de carga; c√©ntrate en **equilibrio y variedad de la rutina**.

   ## Plan para Pr√≥xima Sesi√≥n
   - Da 3-4 recomendaciones **generales para toda la sesi√≥n**
   - Usa el historial y las m√©tricas globales como referencia
   - No repitas ajustes ya dados en ‚ÄúAn√°lisis por Ejercicio‚Äù
   - Enf√≥cate en progresi√≥n global (ej: "mant√©n la constancia de tiempos", "incrementa 1 serie en todo el entrenamiento", "equilibra m√°s trabajo de tir√≥n/empuje")
   - A√±ade un consejo pr√°ctico de preparaci√≥n o recuperaci√≥n (ej: hidrataci√≥n, sue√±o, movilidad antes de empezar)
   - A√±ade un peso recomendado si lo ves oportuno.

   ## Mensaje Motivacional
   - Personalizado seg√∫n el rendimiento y evoluci√≥n
   - Reconoce el esfuerzo y los logros
   - Si hay historial, menciona la consistencia o mejoras
   - Termina con energ√≠a positiva y emojis

4. CONSIDERACIONES ESPECIALES:
   - Si es el primer entrenamiento, enf√≥cate en establecer una l√≠nea base
   - Si hay tendencia negativa en el historial, s√© comprensivo y motivador
   - Si hay tendencia positiva, celebra el progreso
   - Ajusta el tono seg√∫n el nivel de satisfacci√≥n general
   ${
     usuarioData?.peso && usuarioData?.objetivoPeso
       ? `- Considera el objetivo de peso del usuario en tus recomendaciones`
       : ""
   }

IMPORTANTE: S√© espec√≠fico con n√∫meros cuando des recomendaciones de ajuste, pero s√© m√°s general y motivador cuando las cosas van bien. El objetivo es guiar sin sobrecargar de informaci√≥n. S√â MUY ESTRICTO CON EL FORMATO Y EL IDIOMA.`;
  }

  async analizarRutina(datosRutina) {
    const prompt = this.construirPromptAnalisisRutina(datosRutina);
    return this.generateResponse(prompt, {
      temperature: 0.7,
      maxTokens: 500, // Menos tokens para an√°lisis m√°s breve
    });
  }

  construirPromptAnalisisRutina(datos) {
    const { rutina, metricas, usuarioData } = datos;

    const contextoUsuario = usuarioData
      ? `
DATOS DEL USUARIO:
- Peso: ${usuarioData.peso || "No especificado"} kg
- Altura: ${usuarioData.altura || "No especificada"} cm
- Objetivo de peso: ${usuarioData.objetivoPeso || "No especificado"} kg
- Experiencia: ${
          usuarioData.entrenamientosCompletados || 0
        } entrenamientos completados
`
      : "Sin datos del usuario disponibles.";

    return `Eres un entrenador personal experto analizando una rutina de gimnasio.
${contextoUsuario}

RUTINA: "${rutina.nombre}"
- Nivel: ${rutina.nivel}/5
- D√≠as de entrenamiento: ${rutina.dias.length}
- Descripci√≥n: ${rutina.descripcion || "Sin descripci√≥n"}

ESTRUCTURA DE LA RUTINA:
${rutina.dias
  .map((dia, index) => {
    return `
D√≠a ${index + 1}: ${dia.nombre}
Ejercicios: ${dia.ejercicios.length}
${dia.ejercicios
  .map(
    (ej) =>
      `  - "${ej.nombreEspanol}": ${ej.series}x${ej.repeticiones} (${ej.descanso}s descanso)`
  )
  .join("\n")}`;
  })
  .join("\n")}

M√âTRICAS:
- Volumen total semanal: ${metricas.volumenTotal} repeticiones
- Tiempo estimado por sesi√≥n: ${Math.round(
      metricas.tiempoEstimado / rutina.dias.length
    )} minutos

INSTRUCCIONES PARA TU AN√ÅLISIS BREVE:

-  FORMATO: Usa markdown con "## " para t√≠tulos y "* " para listas.

-  IDIOMA: Responde √öNICAMENTE en espa√±ol.

-  ESTRUCTURA, COMO DEBE SER LA SALIDA(m√°ximo 3 secciones cortas):

   ## Evaluaci√≥n General
   - 2-3 l√≠neas sobre la estructura y balance de la rutina
   - Menciona si es apropiada para el nivel indicado

   ## Puntos Fuertes y √Åreas de Mejora
   - 2-3 puntos fuertes de la rutina
   - 1-2 sugerencias de mejora (sin recomendar ejercicios espec√≠ficos)

   ## Consejos de Progresi√≥n
   - 2-3 consejos pr√°cticos para sacar el m√°ximo provecho
   - Sugerencias sobre progresi√≥n de cargas o frecuencia

-  IMPORTANTE:
   - S√â CONCISO: M√°ximo 10-12 l√≠neas en total
   - SIEMPRE usa los nombres en espa√±ol de los ejercicios cuando los menciones
   - NO recomiendes ejercicios espec√≠ficos
   - Usa un tono motivador y profesional
   - Incluye 1-2 emojis relevantes para hacerlo amigable

Responde √öNICAMENTE en espa√±ol con el an√°lisis breve.`;
  }
}

module.exports = {
  ollamaService: new OllamaService(),
  initializeAI: () => new OllamaService().initializeAI(),
};
